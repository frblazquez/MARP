%   Copyright © 2019
%
%   Francisco Javier Blázquez Martínez ~ frblazqu@ucm.es
%
%   Double degree in Mathematics-Computer engineering.
%   Complutense university, Madrid.

%--------------------------------------------------------------------------
% CABECERA DEL DOCUMENTO - IMPORTACIÓN DE PAQUETES
%--------------------------------------------------------------------------
\documentclass[letterpaper,12pt]{article}
\usepackage{tabularx} % extra features for tabular environment
\usepackage{amsmath}  % improve math presentation
\usepackage{graphicx} % takes care of graphic including machinery
\usepackage[margin=1in,letterpaper]{geometry} % decreases margins
\usepackage{cite} % takes care of citations
\usepackage[final]{hyperref} % adds hyper links inside the generated pdf file
\hypersetup{
	colorlinks=true,       % false: boxed links; true: colored links
	linkcolor=blue,        % color of internal links
	citecolor=blue,        % color of links to bibliography
	filecolor=magenta,     % color of file links
	urlcolor=blue         
}

\usepackage[utf8]{inputenc}                 % Using Unicode encoding
\usepackage[spanish]{babel}                 % Writing in Spanish language
%\usepackage{listings}                       % For including C++ code
\setlength{\parindent}{0mm}                 % Paragraph indentation null
\setlength{\parskip}{\baselineskip}         % Distance among paragraphs

%--------------------------------------------------------------------------
%   PARA INCLUIR CÓDIGO C++ EN EL DOCUMENTO
%--------------------------------------------------------------------------
\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\usepackage{listings}
\lstset{ frame=Ltb,
framerule=0pt,
aboveskip=0.5cm,
framextopmargin=3pt,
framexbottommargin=3pt,
framexleftmargin=0.4cm,
framesep=0pt,
rulesep=.4pt,
backgroundcolor=\color{gray97},
rulesepcolor=\color{black},
%
stringstyle=\ttfamily,
showstringspaces = false,
basicstyle=\small\ttfamily,
commentstyle=\color{gray45},
keywordstyle=\bfseries,
%
numbers=left,
numbersep=15pt,
numberstyle=\tiny,
numberfirstline = false,
breaklines=true,
}

% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
{\lstset{#1}\pagebreak[0]}{\pagebreak[0]}

\lstdefinestyle{consola}
{basicstyle=\scriptsize\bf\ttfamily,
backgroundcolor=\color{gray75},
}

\lstdefinestyle{C}
{language=C,
}

%--------------------------------------------------------------------------
% INICIO DEL DOCUMENTO - TÍTULO, AUTOR, FECHA ...
%--------------------------------------------------------------------------
\begin{document}

\title{\bf{Implementación detallada de Splay Trees}}
\author{Francisco Javier Blázquez Martínez}
\date{}
\maketitle

%--------------------------------------------------------------------------
% RESUMEN INICIAL
%--------------------------------------------------------------------------
\begin{abstract}

Trabajo realizado en el marco de la asignatura \textit{Métodos algorítmicos 
en resolución de problemas}. Se incluyen sendas implementaciones de árboles 
de búsqueda autoajustables en \textit{C++} y \textit{Java} junto con detalles
de la implementación, aclaraciones y posibles modificaciones para poder 
adaptar esta curiosa estructura de datos a otros usos.

\end{abstract}

%--------------------------------------------------------------------------
%INICIO DEL CUERPO DEL DOCUMENTO
%--------------------------------------------------------------------------
\section{Introducción:}

Los splay trees aparecen en 1985 ideados por Robert Tarjan y Daniel Selator.
Estos no son sino árboles binarios de búsqueda con una peculiaridad, una 
operación interna sobre los nodos llamada "\textit{splay}". Esta operación, 
invisible en todo momento al usuario, actúa sobre un nodo del árbol con el 
resultado de transformar el árbol de partida en un árbol binario de búsqueda 
equivalente (manteniendo exactamente los elementos iniciales) en el cual la 
raiz es el nodo seleccionado. Intuitivamente, esta operación se emplea para 
conseguir que elementos recientemente requeridos se encuentren cerca de la 
raíz y, por tanto, sea más rápido volver a acceder a ellos. De aquí proviene
su apellido "\textit{autoajustable}" pues esta operación de splay consigue 
que el árbol de preferencia en alturas menores a elementos más empleados en
cualquier secuencia de operaciones.

El principal inconveniente de esta estructura de datos, sin embargo, es que, 
a diferencia de los árboles AVL o los árboles Red-Black, no se mantiene 
ningún invariante en la altura del árbol, pudiendo llegar a ser esta del 
orden del número de elementos. Como ya sabemos, búsqueda, insercción y 
borrado en un árbol binario son operaciones del orden de la altura del árbol.
Esto quiere decir que el coste en el caso peor de estas operaciones en splay 
trees es \textit{O(n)}. A pesar de esto, y precisamente el hecho de su 
publicación por R. Tarjan y D. Selator, se puede demostrar que en cualquier 
secuencia de inserciones, borrados y búsquedas de elementos estas operaciones
tienen un coste amortizado logarítmico. De hecho, se puede aprovechar esta 
propiedad de los splay trees de que elementos accedidos recientemente son 
fácilmente accesibles para conseguir una mayor eficiencia bajo ciertas 
circunstancias (no aleatorias). Aquí nos limitaremos a la implementación,
para una mayor comprensión consultar la bibliografía.

%\cite{melissinos, Cyr, Wiki}   % Para tener un ejemplo de cómo citar

\section{Implementación:}

Como ya hemos mencionado, los splay trees son esencialmente árboles de
búsqueda binarios y, como tales, tienen infinidad de aplicaciones. Es preciso
antes de comenzar la implementación concretar las operaciones que vamos a 
permitir ejecutar al usuario. En mi caso he optado por aplicar los splay 
trees para crear una estrucura de datos de conjunto ordenado de elementos de
tipo genérico, con un orden que puede ser especificado por el usuario.
La interfaz pública del usuario se puede consultar en la tabla inferior.

\begin{center}
\begin{tabular}{|l|c|c|l|}

	\hline
	Operación & Coste & Caso peor & Descripción\\
	\hline
    splay\_tree()    & O(1)     &  O(1)& Crea un conjunto vacío\\
	\hline
    \~splay\_tree()  & O(n)     & O(n) & Vacía el conjunto y libera la memoria\\ 
	\hline
	bool empty()     & O(1)     & O(1) & Devuelve true si el conjunto está vacío\\
	\hline
	bool insert(elem)& O(log(n))& O(n) & Devuelve true si inserta el elemento\\
	\hline
	bool erase(elem) & O(log(n))& O(n) & Devuelve true si elimina el elemento\\
	\hline
	bool find(elem)  & O(log(n))& O(n) & Devuelve true si \textit{elem} está en el conjunto\\
	\hline
	void print()     & O(n)     & O(n) & Muestra en inorder los elementos y su altura\\
	\hline
	
\end{tabular}
\end{center}

El diseño se ha realizado así para asemejarse en la medida a la clase set de
la librería estándar de \textit{C++}. De hecho, que detrás de esta interfaz
se encuentra la estructura de datos de splay tree es algo invisible al 
usuario. Una diferencia a destacar con respecto la clase set de la 
\textit{C++ STL} es que se incluye el método \textit{print()}. Esto es para
poder visualizar en consola la estructura completa del conjunto, cómo se
almacenan y cómo varía su situación relativa con las distintas operaciones, 
más allá del uso como conjunto de la clase. Cabe destacar también de la 
implementación las siguientes características:

\begin{enumerate}
\setlength{\parskip}{0mm}         % Distance among paragraphs

\item No se permite la inserción repetida de un mismo elemento, esto es, 
      nunca nuestro splay tree subyacente al conjunto implementado contendrá
      dos nodos con elementos iguales. Para garantizar esto es necesario 
      también que se de el punto número dos.
\item El usuario puede decidir el orden que rige la estructura siempre que 
      este constituya un orden estricto sobre el conjunto de posibles 
      elementos. La estructura implementada esta preparada para funcionar con 
      un comparador cualquiera pero puede llegar a estados inconsistentes si 
      esta condición no se satisface.
\item A diferencia de otras implementaciones de splay trees, no se contempla
      la unión de árboles/conjuntos en la estructura implementada. Esto tiene
      importancia en los métodos de inserción y borrado de elementos.
\item La estructura de splay tree que subyace a la implementación de conjunto
      puede ser implementada sin añadir atributos adicionales a los nodos del
      árbol (más allá del elemento y los punteros a ambos hijos). Por una 
      mayor sencillez en la implementación he optado por añadir un atributo,
      un puntero al padre para poder actualizar sus atributos de forma 
      sencilla en \textit{O(1)}.
     
\end{enumerate}


\section{Algoritmos:}

\subsection{Atributos de la clase:}

Como ya hemos dicho, hemos optado por añadir como atributo propio de cada nodo
un puntero a su nodo padre para simplificar el código. También hemos optado
por que tanto la clase nodo (invisible al usuario) como los atributos de la 
clase sean \textit{protected} y no \textit{private} en vista a posibles 
modificaciones futuras. Abajo se muestra la declaración de la clase sin
métodos.

\begin{lstlisting}
template<typename T, typename Comp = std::less<T>>
class splay_tree
{
  protected:
    struct Node
    {
      T     elem;
      Node* left;
      Node* right;
      Node* parent;

      Node(Node* l, T const& e, Node* r, Node* p) 
          :elem(e),left(l),right(r),parent(p) {}
    };

    Node* root;
    Comp  lower;
}; //splay_tree
\end{lstlisting}

\subsection{Inserción:}

La inserción es igual que en un árbol binario de búsqueda (actualizando 
también el atributo extra añadido en los nodos) con la salvedad de que al
terminar el proceso se realiza una llamada al método splay con el nodo 
insertado, de realizarse la inserción, o con aquel nodo que ya contiene la 
clave a insertar.

\begin{lstlisting}
template<typename T, typename Comp>
bool splay_tree<T, Comp>::insert(T const& elem)
{
  Node* father = nullptr; Node* node = root;

  while(node != nullptr)
  {
    father = node;

         if(lower(elem, node->elem))     node = node->left;
    else if(lower(node->elem, elem))     node = node->right;
    else {splay(node); return false;} // The element is already in the tree
  }

  node = new Node(nullptr, elem, nullptr, father);

  if(father != nullptr)
    {if(lower(elem, father->elem)) father->left = node;
     else                          father->right= node;}
  else
    root = node;

  splay(node);  return true;
}
\end{lstlisting}



\section{Analysis}

In this section you will need to show your experimental results. Use tables and
graphs when it is possible. Table~\ref{tbl:bins} is an example.

\begin{table}[ht]
\begin{center}
\caption{Every table needs a caption.}
\label{tbl:bins} % spaces are big no-no withing labels
\begin{tabular}{|cc|} 
\hline
\multicolumn{1}{|c}{$x$ (m)} & \multicolumn{1}{c|}{$V$ (V)} \\
\hline
0.0044151 &   0.0030871 \\
0.0021633 &   0.0021343 \\
0.0003600 &   0.0018642 \\
0.0023831 &   0.0013287 \\
\hline
\end{tabular}
\end{center}
\end{table}

Fig.~\ref{fig:samplesetup} and Fig.~\ref{fig:exp_plots}.

\begin{figure}[ht] 
  \centering
      \includegraphics[width=0.5\columnwidth]{sr_squeezing_vs_detuning}

% some figures do not need to be too wide
        \caption{
                \label{fig:exp_plots}  
                Every plot must have axes labeled.
        }
\end{figure}


\section{Conclusions}
Here you briefly summarize your findings.

%++++++++++++++++++++++++++++++++++++++++
% References section will be created automatically 
% with inclusion of "thebibliography" environment
% as it shown below. See text starting with line
% \begin{thebibliography}{99}
% Note: with this approach it is YOUR responsibility to put them in order
% of appearance.

\begin{thebibliography}{99}

\bibitem{melissinos}
A.~C. Melissinos and J. Napolitano, \textit{Experiments in Modern Physics},
(Academic Press, New York, 2003).

\bibitem{Cyr}
N.\ Cyr, M.\ T$\hat{e}$tu, and M.\ Breton,
% "All-optical microwave frequency standard: a proposal,"
IEEE Trans.\ Instrum.\ Meas.\ \textbf{42}, 640 (1993).

\bibitem{Wiki} \emph{Expected value},  available at
\texttt{http://en.wikipedia.org/wiki/Expected\_value}.

\end{thebibliography}


\end{document}
